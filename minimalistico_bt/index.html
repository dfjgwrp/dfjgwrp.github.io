

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <!-- Imporant meta information to make the page as rigid as possible on mobiles, to avoid unintentional zooming on the page itself  -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Minimalistico BT</title>
    
<style>
body {
	background: #fff0;
  margin: 0;
  padding: 0;
}



html {
  margin: 0;
  padding: 0;
  background: #fff0;
}
* {
  touch-action: manipulation;
}
*,
*:before,
*:after {
  box-sizing: border-box;
}

body {
  position: relative;
  letter-spacing: 2px;
  font-size: 11px;
  font-family: 'Arial', sans-serif;
  width: 100%;
  height: 100vh;
}
.wrapper {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
#c {
  position: absolute;
  top: 0;
  width: 100%;
  height: 100%;
  display: block;
}

</style>
</head>



<body>

<div class="wrapper">


<canvas id="c"></canvas>



</div>


</body>

</html>


<script src='./three.min.js'></script>

<script>



  	let scene,  
    renderer,
    camera,
    model,                              
    mixer,
		controls;                        

    const canvas = document.querySelector('#c');
    const backgroundColor = 0x777777;
    
    // Init the scene
    scene = new THREE.Scene();
   //scene.background = new THREE.Color(backgroundColor);
    //scene.fog = new THREE.Fog(backgroundColor, 60, 100);
    
    // Init the renderer
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true  });
    renderer.shadowMap.enabled = false;
		renderer.setClearColor( 0x000000, 0 );
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    // Add a camera
    camera = new THREE.PerspectiveCamera(
      15,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.x = -38.07; 
    camera.position.y = 20.13;
    camera.position.z = 37.42;
    
		camera.lookAt(-0, -9.9	, 0);




		var mouseX = 0, mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;








































		var orangeMat1 = new THREE.MeshPhongMaterial( { color: 0x000000,     transparent: true,specular: 0xffffff, side: THREE.DoubleSide, shininess: 0, wireframe: true, opacity: 1 } );









		const size = 8;
		const widthSegments = 0;
		const heightSegments = 0;
		const depthSegments = 0;

		const boxGeometry = new THREE.BoxBufferGeometry(
		size, size, size,
		widthSegments, heightSegments, depthSegments);


		const cube1 = new THREE.Mesh(boxGeometry, orangeMat1);


		//SCENE 2 POSITION
		cube1.position.x = 6.7;
		cube1.position.y = -14.5;
		cube1.position.z = -6;
		cube1.rotation.x = 0.7;
		cube1.rotation.y = 2.7;
		cube1.rotation.z = 3.3;
		//cube1.scale.set(1.3,1.3,1.3);



	  scene.add(cube1);









    // Add lights
    let hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.3);
    hemiLight.position.set(0, 90, 0);
    // Add hemisphere light to scene
    scene.add(hemiLight);
    let dirLight = new THREE.DirectionalLight(0xffffff, 0.84);
    dirLight.position.set(-8, 12, 8);
	  dirLight.target.position.set(6.7, -13, -7);

    scene.add(dirLight);



















		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		function onDocumentMouseMove( event ) {

		mouseX = ( event.clientX - windowHalfX );
		mouseY = ( event.clientY - windowHalfY );

		}



    function update() {
 
    
    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }


    renderer.render(scene, camera);
    requestAnimationFrame(update);



		cube1.rotation.x += ( mouseX - camera.position.x ) * .0000019;
		cube1.rotation.y += ( - ( mouseY - 59 ) - camera.position.y ) * .0000136;


  }



  






   function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    let width = window.innerWidth;
    let height = window.innerHeight;
    let canvasPixelWidth = canvas.width / window.devicePixelRatio;
    let canvasPixelHeight = canvas.height / window.devicePixelRatio;

    const needResize =
      canvasPixelWidth !== width || canvasPixelHeight !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }
  



update();











</script>











